name: DevRel Notification

on:
  push:
    paths:
      - examples/**
      - smartcontracts/**
      - docs/**
  pull_request:
    paths:
      - examples/**
      - smartcontracts/**
      - docs/**

jobs:
  notify:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Create or Update Issue
        uses: actions/github-script@v6
        with:
          script: |
            const { owner, repo } = context.repo;
            const issueTitle = 'Checkout new changes in Examples or Docs';

            // Determine if this was triggered by a push or pull request
            const isPR = !!context.payload.pull_request;
            const triggerLink = isPR
              ? context.payload.pull_request.html_url
              : `${context.payload.repository.html_url}/commit/${context.sha}`;
            
            const triggerDescription = isPR
              ? context.payload.pull_request.body || "No PR description provided."
              : context.payload.head_commit.message || "No commit message provided.";

            const triggerType = isPR ? "PR" : "commit";

            let modifiedFiles = [];
            if (isPR) {
              // Fetch the list of files changed in the pull request
              const prNumber = context.payload.pull_request.number;
              const files = await github.rest.pulls.listFiles({
                owner,
                repo,
                pull_number: prNumber
              });

              modifiedFiles = files.data.map(file => `- [${file.filename}](${file.blob_url})`);
            } else {
              // For push events, gather the list of modified files from the commits
              const commits = context.payload.commits;
              commits.forEach(commit => {
                if (commit.modified) {
                  modifiedFiles.push(...commit.modified.map(file => `- [${file}](${context.payload.repository.html_url}/blob/${commit.id}/${file})`));
                }
                if (commit.added) {
                  modifiedFiles.push(...commit.added.map(file => `- [${file}](${context.payload.repository.html_url}/blob/${commit.id}/${file})`));
                }
                if (commit.removed) {
                  modifiedFiles.push(...commit.removed.map(file => `- [${file}](${context.payload.repository.html_url}/blob/${commit.id}/${file})`));
                }
              });
            }

            const filesList = modifiedFiles.length > 0 
              ? `### Modified Files:\n${modifiedFiles.join('\n')}`
              : 'No modified files found.';

            const issueBody = `@simonerom Changes were detected in the 'docs', 'examples', or 'smartcontracts' folder. 
            Please review the changes and update the docs portal if required.
            
            The changes were triggered by this ${triggerType}:
            
            [${triggerLink}](${triggerLink}) 
            _${triggerDescription}_

            ${filesList}`;

            try {
              const issues = await github.rest.issues.listForRepo({
                owner,
                repo,
                state: 'open',
                labels: 'notification'
              });

              if (issues.data.length === 0) {
                // Create a new issue if no open issues with the label exist
                await github.rest.issues.create({
                  owner,
                  repo,
                  title: issueTitle,
                  body: issueBody,
                  labels: ['notification']
                });
              } else {
                // Comment on the first open issue with the label
                const issueNumber = issues.data[0].number;
                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number: issueNumber,
                  body: issueBody
                });
              }
            } catch (error) {
              console.error('Error creating or updating issue:', error);
              throw error;
            }
        env:
          GITHUB_TOKEN: ${{ secrets.PAT_TOKEN }}  # Using PAT_TOKEN if needed for permissions
